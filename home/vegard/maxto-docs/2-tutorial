import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, v as validate_slots, e as element, t as text, a as space, g as claim_element, h as children, j as claim_text, b as detach_dev, f as claim_space, l as add_location, x as attr_dev, m as insert_dev, n as append_dev, w as noop } from './client.1d2e5f1c.js';

/* src/routes/old-configuration/6-updates.html generated by Svelte v3.23.0 */

const file = "src/routes/old-configuration/6-updates.html";

function create_fragment(ctx) {
	let html;
	let head;
	let title;
	let t0;
	let t1;
	let body;
	let h1;
	let t2;
	let t3;
	let p0;
	let t4;
	let t5;
	let section0;
	let p1;
	let t6;
	let t7;
	let p2;
	let t8;
	let t9;
	let section1;
	let h3;
	let t10;
	let t11;
	let p3;
	let t12;
	let t13;
	let p4;
	let t14;
	let t15;
	let h2;
	let t16;
	let t17;
	let p5;
	let t18;
	let em0;
	let t19;
	let t20;
	let em1;
	let t21;
	let t22;

	const block = {
		c: function create() {
			html = element("html");
			head = element("head");
			title = element("title");
			t0 = text("Updates");
			t1 = space();
			body = element("body");
			h1 = element("h1");
			t2 = text("Updates");
			t3 = space();
			p0 = element("p");
			t4 = text("MaxTo will update itself if you give it a chance.");
			t5 = space();
			section0 = element("section");
			p1 = element("p");
			t6 = text("Automatic updates are not available if you install MaxTo using the ZIP archive.");
			t7 = space();
			p2 = element("p");
			t8 = text("You can disable MaxTo's automatic updates if you for any reason feel like you need to stick to the version you\r\n        have currently.");
			t9 = space();
			section1 = element("section");
			h3 = element("h3");
			t10 = text("A note on updates");
			t11 = space();
			p3 = element("p");
			t12 = text("Currently, MaxTo checks for updates every time it is started. If an update is available, it will be\r\n            downloaded and installed.\r\n            The next time you start MaxTo, the update will be applied.");
			t13 = space();
			p4 = element("p");
			t14 = text("There are currently no information in the user interface presented when an update has been installed or is\r\n            ready to install.\r\n            We are working on this.");
			t15 = space();
			h2 = element("h2");
			t16 = text("Update channel");
			t17 = space();
			p5 = element("p");
			t18 = text("You can pick if you want to receive updates as we are testing, or if you want to wait until everything is\r\n        stable. If you want to be on the bleeding edge and try out new features early, you can try out the\r\n        ");
			em0 = element("em");
			t19 = text("Beta");
			t20 = text(" or ");
			em1 = element("em");
			t21 = text("Alpha");
			t22 = text(" update channels.");
			this.h();
		},
		l: function claim(nodes) {
			html = claim_element(nodes, "HTML", {});
			var html_nodes = children(html);
			head = claim_element(html_nodes, "HEAD", {});
			var head_nodes = children(head);
			title = claim_element(head_nodes, "TITLE", {});
			var title_nodes = children(title);
			t0 = claim_text(title_nodes, "Updates");
			title_nodes.forEach(detach_dev);
			head_nodes.forEach(detach_dev);
			t1 = claim_space(html_nodes);
			body = claim_element(html_nodes, "BODY", {});
			var body_nodes = children(body);
			h1 = claim_element(body_nodes, "H1", {});
			var h1_nodes = children(h1);
			t2 = claim_text(h1_nodes, "Updates");
			h1_nodes.forEach(detach_dev);
			t3 = claim_space(body_nodes);
			p0 = claim_element(body_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t4 = claim_text(p0_nodes, "MaxTo will update itself if you give it a chance.");
			p0_nodes.forEach(detach_dev);
			t5 = claim_space(body_nodes);
			section0 = claim_element(body_nodes, "SECTION", { class: true });
			var section0_nodes = children(section0);
			p1 = claim_element(section0_nodes, "P", {});
			var p1_nodes = children(p1);
			t6 = claim_text(p1_nodes, "Automatic updates are not available if you install MaxTo using the ZIP archive.");
			p1_nodes.forEach(detach_dev);
			section0_nodes.forEach(detach_dev);
			t7 = claim_space(body_nodes);
			p2 = claim_element(body_nodes, "P", {});
			var p2_nodes = children(p2);
			t8 = claim_text(p2_nodes, "You can disable MaxTo's automatic updates if you for any reason feel like you need to stick to the version you\r\n        have currently.");
			p2_nodes.forEach(detach_dev);
			t9 = claim_space(body_nodes);
			section1 = claim_element(body_nodes, "SECTION", { class: true });
			var section1_nodes = children(section1);
			h3 = claim_element(section1_nodes, "H3", {});
			var h3_nodes = children(h3);
			t10 = claim_text(h3_nodes, "A note on updates");
			h3_nodes.forEach(detach_dev);
			t11 = claim_space(section1_nodes);
			p3 = claim_element(section1_nodes, "P", {});
			var p3_nodes = children(p3);
			t12 = claim_text(p3_nodes, "Currently, MaxTo checks for updates every time it is started. If an update is available, it will be\r\n            downloaded and installed.\r\n            The next time you start MaxTo, the update will be applied.");
			p3_nodes.forEach(detach_dev);
			t13 = claim_space(section1_nodes);
			p4 = claim_element(section1_nodes, "P", {});
			var p4_nodes = children(p4);
			t14 = claim_text(p4_nodes, "There are currently no information in the user interface presented when an update has been installed or is\r\n            ready to install.\r\n            We are working on this.");
			p4_nodes.forEach(detach_dev);
			section1_nodes.forEach(detach_dev);
			t15 = claim_space(body_nodes);
			h2 = claim_element(body_nodes, "H2", {});
			var h2_nodes = children(h2);
			t16 = claim_text(h2_nodes, "Update channel");
			h2_nodes.forEach(detach_dev);
			t17 = claim_space(body_nodes);
			p5 = claim_element(body_nodes, "P", {});
			var p5_nodes = children(p5);
			t18 = claim_text(p5_nodes, "You can pick if you want to receive updates as we are testing, or if you want to wait until everything is\r\n        stable. If you want to be on the bleeding edge and try out new features early, you can try out the\r\n        ");
			em0 = claim_element(p5_nodes, "EM", {});
			var em0_nodes = children(em0);
			t19 = claim_text(em0_nodes, "Beta");
			em0_nodes.forEach(detach_dev);
			t20 = claim_text(p5_nodes, " or ");
			em1 = claim_element(p5_nodes, "EM", {});
			var em1_nodes = children(em1);
			t21 = claim_text(em1_nodes, "Alpha");
			em1_nodes.forEach(detach_dev);
			t22 = claim_text(p5_nodes, " update channels.");
			p5_nodes.forEach(detach_dev);
			body_nodes.forEach(detach_dev);
			html_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(title, file, 3, 4, 22);
			add_location(head, file, 2, 0, 10);
			add_location(h1, file, 7, 4, 69);
			attr_dev(p0, "class", "lead");
			add_location(p0, file, 8, 4, 91);
			add_location(p1, file, 11, 8, 205);
			attr_dev(section0, "class", "important");
			add_location(section0, file, 10, 4, 168);
			add_location(p2, file, 16, 4, 339);
			add_location(h3, file, 22, 8, 537);
			add_location(p3, file, 24, 8, 575);
			add_location(p4, file, 30, 8, 828);
			attr_dev(section1, "class", "note");
			add_location(section1, file, 21, 4, 505);
			add_location(h2, file, 37, 4, 1057);
			add_location(em0, file, 42, 8, 1324);
			add_location(em1, file, 42, 25, 1341);
			add_location(p5, file, 39, 4, 1088);
			add_location(body, file, 6, 0, 57);
			add_location(html, file, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, html, anchor);
			append_dev(html, head);
			append_dev(head, title);
			append_dev(title, t0);
			append_dev(html, t1);
			append_dev(html, body);
			append_dev(body, h1);
			append_dev(h1, t2);
			append_dev(body, t3);
			append_dev(body, p0);
			append_dev(p0, t4);
			append_dev(body, t5);
			append_dev(body, section0);
			append_dev(section0, p1);
			append_dev(p1, t6);
			append_dev(body, t7);
			append_dev(body, p2);
			append_dev(p2, t8);
			append_dev(body, t9);
			append_dev(body, section1);
			append_dev(section1, h3);
			append_dev(h3, t10);
			append_dev(section1, t11);
			append_dev(section1, p3);
			append_dev(p3, t12);
			append_dev(section1, t13);
			append_dev(section1, p4);
			append_dev(p4, t14);
			append_dev(body, t15);
			append_dev(body, h2);
			append_dev(h2, t16);
			append_dev(body, t17);
			append_dev(body, p5);
			append_dev(p5, t18);
			append_dev(p5, em0);
			append_dev(em0, t19);
			append_dev(p5, t20);
			append_dev(p5, em1);
			append_dev(em1, t21);
			append_dev(p5, t22);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(html);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<_6_updates> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("_6_updates", $$slots, []);
	return [];
}

class _6_updates extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "_6_updates",
			options,
			id: create_fragment.name
		});
	}
}

export default _6_updates;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi11cGRhdGVzLmRiOTM5ZjEyLmpzIiwic291cmNlcyI6W10sInNvdXJjZXNDb250ZW50IjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
